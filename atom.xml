<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>空明的博客</title>
  
  
  <link href="https://kongmingzi.com/atom.xml" rel="self"/>
  
  <link href="https://kongmingzi.com/"/>
  <updated>2023-09-30T12:50:34.478Z</updated>
  <id>https://kongmingzi.com/</id>
  
  <author>
    <name>空明</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Rust的生命周期</title>
    <link href="https://kongmingzi.com/2023/09/30/Rust%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>https://kongmingzi.com/2023/09/30/Rust%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</id>
    <published>2023-09-30T13:00:00.000Z</published>
    <updated>2023-09-30T12:50:34.478Z</updated>
    
    <content type="html"><![CDATA[<p>Rust对于内存回收的机制，采取了一种与众不同的方式，当然这也不是新的概念，即<strong>RAII（Resource Acquisition Is Initialization）</strong>的机制，这种机制起源于C++，但是在其它语言中都以不同的方式出现过，Rust不仅将RAII作为内存的主要回收手段，还加入了更加严格的编译时检查，以防止资源的不当使用，Rust的内存管理方式不同于C++的手动内存管理方式，也不同于Java虚拟机的垃圾回收机制进行内存的自动回收，对于Rust学习者，理解RAII机制是非常重要的，它可以帮助你理解Rust编译器需要依靠你进行生命周期声明标注。</p><p>Rust为了保证内存安全，采用了三种核心思想，分别是：所有权（ownership）、借用（borrowing）、生命周期（lifetimes）。阅读本篇文章时，希望读者已经对所有权和借用有所了解。相较于生命周期，这两个概念更为简单。如果你尚不了解，建议花费30分钟时间先进行学习。不过，如果你只想了解生命周期的内容，也是可以的。但我不会在本文中对所有权和借用进行深入解释。如果想了解这两个概念，可以参考以下资料：</p><p>RAII 到底是什么？中文直译为”资源获取即初始化”，熟悉C++的朋友对这个概念或许并不陌生，RAII要求资源的有效期与持有资源的对象生命周期严格绑定，即由对象的构造函数完成资源的分配，同时由析构函数完成资源的释放。在这种要求下，只要对象能正确的析构就不会出现资源泄露问题。RAII的设计最开始是为了解决C++异常时资源释放的问题，为了不涉及任何语言的写法，以下代码我用一段伪代码展示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 未使用RAII，通过finally确保在发生异常时资源仍然能够被正常回收</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Socket socket;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    socket = <span class="keyword">new</span> <span class="built_in">Sokcet</span>();</span><br><span class="line">    <span class="built_in">access</span>(socket);</span><br><span class="line">  &#125; finally &#123;</span><br><span class="line">    socket.<span class="built_in">close</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用RAII</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">try</span> (Socket socket = <span class="keyword">new</span> <span class="built_in">Socket</span>()) &#123;</span><br><span class="line">    <span class="built_in">access</span>(socket);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Rust中的应用是一种隐式的方式：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;这是一个字符串&quot;</span>);</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">y</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;这是一个字符串&quot;</span>);</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, y);</span><br><span class="line">    &#125; <span class="comment">// 离开此作用域时，析构函数将y进行回收</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, x);</span><br><span class="line">    <span class="title function_ invoke__">test</span>();</span><br><span class="line">&#125; <span class="comment">// 离开此作用域时，析构函数将会将x进行回收</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">test</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;这是一个字符串&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, a);</span><br><span class="line">&#125; <span class="comment">//  在离开此作用域时，析构函数将a进行回收</span></span><br></pre></td></tr></table></figure><p>得益于在离开作用域后会自动回收变量的资源所得到的零成本抽象、无垃圾回收开销及内存安全，我们所要付出的代价就是书写时的思维方式，需要严格遵守规则并调整  PS：这就是为什么你有的时候会被编译器的提示折腾的半死（PS： 这里提一嘴在Rust 1.31后关于引用回收的特性，引用从借用处开始，持续到最后一处使用的地方就算结束）。</p><p>现在请跟我一起看看这段编译绝对不会通过的代码：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">max</span>(a: &amp;<span class="type">i32</span>, b: &amp;<span class="type">i32</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">i32</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">        a</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        b</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Rust会提示你它需要一些帮助：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">error[E0106]: missing lifetime specifier</span><br><span class="line">  --&gt; src/main.rs:16:29</span><br><span class="line">   |</span><br><span class="line">16 | fn max(a: &amp;i32, b: &amp;i32) -&gt; &amp;i32 &#123;</span><br><span class="line">   |           ----     ----     ^ expected named lifetime parameter</span><br><span class="line">   |</span><br><span class="line">   = help: this function&#x27;s return type contains a borrowed value, but the signature does not say whether it is borrowed from `a` or `b`</span><br><span class="line">help: consider introducing a named lifetime parameter</span><br><span class="line">   |</span><br><span class="line">16 | fn max&lt;&#x27;a&gt;(a: &amp;&#x27;a i32, b: &amp;&#x27;a i32) -&gt; &amp;&#x27;a i32 &#123;</span><br><span class="line">   |       ++++     ++          ++          ++</span><br><span class="line"></span><br><span class="line">For more information about this error, try `rustc --explain E0106`.</span><br><span class="line">error: could not compile `lifetime` (bin &quot;lifetime&quot;) due to previous error</span><br></pre></td></tr></table></figure><p>在我解决这个问题之前，请你站在编译器视角看这个问题：</p><ul><li>会返回<code>a</code>还是返回<code>b</code>呢？</li><li>虽然我们知道函数应当返回较大的那个值，但对编译器来说，在非运行时（即编译时），这个信息并不可知，对吗？</li></ul><p>所以编译器在编译时也不知道该返回<code>a</code>和<code>b</code>，可能在使用<code>a</code>的时候<code>a</code>就已经被回收了，亦或是使用<code>b</code>的时候<code>b</code>已经被回收了？看下面示例：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="variable">result</span>;</span><br><span class="line">  <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = <span class="number">10</span>;</span><br><span class="line">    result = <span class="title function_ invoke__">max</span>(&amp;x, &amp;y);</span><br><span class="line">  &#125; <span class="comment">// 离开此作用域时，析构函数会将y进行回收</span></span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, result); <span class="comment">// 此时错误引用了已经被释放了的y，造成悬垂引用！ </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">max</span>(a: &amp;<span class="type">i32</span>, b: &amp;<span class="type">i32</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">i32</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">        a</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        b</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然以上代码是不可以被编译通过的，存在未给方法标注生命周期以及引用了被释放的y，写这段代码只是为了告诉读者这个现象，此时就会出现悬垂引用，我们需要给编译器(给编译器写注释)一些提示，这些提示就是通过生命周期的标识的方式告诉编译器，你放心，我心里有数！我知道这些引用的生命周期关系是怎么样的，不会像上述例子一样瞎玩的！</p><p>添加生命周期标识只需要 <code>&#39;任意字符</code>，但通常我们会使用这种<code>&#39;a</code>、<code>&#39;b&#39;</code>这种简单的命名来定义生命周期标识，例如：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&amp;<span class="symbol">&#x27;a</span> <span class="type">i32</span>;  <span class="comment">// 这是一个标识了生命周期a的不可变引用</span></span><br><span class="line">&amp;<span class="symbol">&#x27;b</span> <span class="keyword">mut</span> <span class="type">i32</span>; <span class="comment">// 这是一个标识了生命周期b的可变引用</span></span><br></pre></td></tr></table></figure><p>利用生命周期标识将函数进行代码上的调整：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">max</span>&lt;<span class="symbol">&#x27;a</span>&gt;(a: &amp;<span class="symbol">&#x27;a</span> <span class="type">i32</span>, b: &amp;<span class="symbol">&#x27;a</span> <span class="type">i32</span>) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;a</span> <span class="type">i32</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">        a</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        b</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码：声明了生命周期<code>&#39;a</code>的标识将其作用在了<code>a</code>和<code>b</code>方法参数以及返回参数上，这是在告诉编译器我的2个方法参数以及返回值之间是相互之间有关联的，返回的引用生命周期不会超过a和b的生命周期范围，也就是不会比方法参数俩的任意一个生命周期还要长，如果出现了，编译器会毫不犹豫的拒绝执行你的代码，读者需要时刻谨记，<strong>书写了生命周期标识，只不过是向编译器阐明了方法参数和返回值的关系上的注释，并不会对引用的实际生命周期造成任何影响，它仅仅是写个编译器的注释！用来帮助编译器确定要执行的代码是否安全</strong>，理解这一段话，对于正在阅读本文的读者来说对于接下来掌握生命周期的这个概念极为重要！</p><p>现在修改一版正确的代码</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="variable">result</span>;</span><br><span class="line">  <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = <span class="number">10</span>;</span><br><span class="line">    result = <span class="title function_ invoke__">max</span>(&amp;x, &amp;y);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, result); </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果在此处执行会报错，因为此处的引用已经超出了生命周期引用</span></span><br><span class="line">  <span class="comment">// 返回的引用不能比方法参数俩的任意一个生命周期还要长！</span></span><br><span class="line">  <span class="comment">// println!(&quot;&#123;&#125;&quot;, result); </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">max</span>&lt;<span class="symbol">&#x27;a</span>&gt;(a: &amp;<span class="symbol">&#x27;a</span> <span class="type">i32</span>, b: &amp;<span class="symbol">&#x27;a</span> <span class="type">i32</span>) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;a</span> <span class="type">i32</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">        a</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        b</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码已然能够正确执行，现在请读者在思考一个问题，请站在编译器的角度：</p><ul><li>思考<code>&#39;a</code>到底等于谁的生命周期？</li></ul><p>如果没有思路，不妨再品一品我上面说的”声明了生命周期<code>&#39;a</code>的标识将其作用在了<code>a</code>和<code>b</code>方法参数以及返回参数上，这是在告诉编译器我的2个方法参数以及返回值之间是相互之间有关联的，返回的引用生命周期不会超过a和b的生命周期范围，也就是不会比方法参数俩的任意一个生命周期还要长。”  答案是：最短的那一个，只要超过了最短的那一个的生命周期范围，就违反了写给编译器的注释不是吗？编译器在编译你的代码的时候会根据书写的标识检查返回的引用的使用是违反了我们的注释，这就是此处我们书写它的意义所在。</p><p>为了再次加强生命周期标注对参数以及返回值的关联关系，我继续再举一个例子：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">test</span>&lt;<span class="symbol">&#x27;a</span>&gt;(a: &amp;<span class="symbol">&#x27;a</span> <span class="type">i32</span>, b: &amp;<span class="type">i32</span>) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;a</span> <span class="type">i32</span> &#123;</span><br><span class="line">    a</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请继续思考一下为何<code>b</code>没有被标识生命周期注解仍然能够编译通过并执行？</p><ol><li>通过生命周期的标注，已经向编译器写好了注释(标识)，已经说明了入参引用与返回值之间的生命周期关系，帮助编译器检查参数与返回值的关系</li><li>编译器检查的时候<code>b</code>入参的引用，确确实实与返回值没有关系，确确实实只会返回<code>a</code>的引用而非其它</li></ol><p>所以能够编译通过</p><p>如果时时刻刻都需要对引用以及返回值进行生命周期的标注，很烦琐很麻烦不是吗？所以Rust可以像自动推导变量类型一样帮助我们自动推导生命周期标注，这也叫做<strong>生命周期省略</strong>，共有以下三条规则：</p><ol><li>每一个引用都会获得独自的生命周期</li><li>若函数的输入只有一个引用类型的参数，那么返回值的生命周期就等于该输入的生命周期</li><li>若存在多个生命周期，且其中一个是<code>&amp;self</code>或者<code>&amp;mut self</code>，则输出的生命周期等于<code>&amp;self</code>的生命周期</li></ol><p>接下来根据消除法则，就可以推导一下为什么之前写的<code>max</code>函数Rust的编译器无法自动推导</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">max</span>(a: &amp;<span class="type">i32</span>, b: &amp;<span class="type">i32</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">i32</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">        a</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        b</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据消除法则一：每一个引用都会获得独自的生命周期</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">max</span>&lt;<span class="symbol">&#x27;a</span>, <span class="symbol">&#x27;b</span>&gt;(a: &amp;<span class="symbol">&#x27;a</span> <span class="type">i32</span>, b: &amp;<span class="symbol">&#x27;b</span> <span class="type">i32</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">i32</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">        a</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        b</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么问题来了，我输出的引用的生命周期是？<code>a</code>还是<code>b</code>？因为二个都有可能返回不得而知，所以这个时候你可以再品品之前说的”2个方法参数以及返回值之间是相互之间有关联”的这句话，可能会豁然开朗哦。</p><p>根据消除法则二：若函数的输入只有一个引用类型参数，那么返回值的生命周期就等于该输入的生命周期，由于存在二个引用类型参数，无法应用。</p><p>根据消除法则三：我们这个并不是一个方法，而是一个函数，也没有定义<code>&amp;self</code>，无法应用。</p><p>接下来演示一个完全符合生命周期省略法则的例子：</p><p>原代码：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">do_something</span>(a: &amp;<span class="type">i32</span>)  <span class="punctuation">-&gt;</span> &amp;<span class="type">i32</span> &#123;</span><br><span class="line">    <span class="comment">// do something.......</span></span><br><span class="line">    <span class="comment">// ba la ba la</span></span><br><span class="line">    a</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>能够完全符合规则一和规则二吧？关于规则三几乎都是在结构体中出现，你理解透这部分内容，结构体中引用的生命周期引用，你仅需记住这一句方可瞬间理解”结构体中的引用，必须比该结构体获得更久”，通透吧？这是为了确保结构体的引用仍然有效时，结构体内部的引用也是有效的，说白了还是为了内存安全防止悬垂引用！</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">wallet</span> = Wallet &#123; color: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Red&quot;</span>) &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">xiaoming</span> = Person &#123; wallet: &amp;wallet &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;小明的钱包颜色是: &#123;&#125;&quot;</span>, xiaoming.<span class="title function_ invoke__">get_wallet_color</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Wallet</span> &#123;</span><br><span class="line">    color: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span>&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    wallet: &amp;<span class="symbol">&#x27;a</span> Wallet,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;<span class="symbol">&#x27;a</span>&gt; Person&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">get_wallet_color</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span> &#123;</span><br><span class="line">        &amp;<span class="keyword">self</span>.wallet.color</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 约等于这样写</span></span><br><span class="line">    <span class="comment">// fn get_wallet_color(&amp;&#x27;a self) -&gt; &amp;&#x27;a str &#123;</span></span><br><span class="line">    <span class="comment">//     &amp;self.wallet.color</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新增一个更换钱包的方法</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">wallet</span> = Wallet &#123;</span><br><span class="line">        color: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;红色&quot;</span>),</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> <span class="variable">new_wallet</span> = Wallet &#123;</span><br><span class="line">        color: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;蓝色&quot;</span>),</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">xiaoming</span> = Person &#123; wallet: &amp;wallet &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;小明的钱包颜色是: &#123;&#125;&quot;</span>, xiaoming.<span class="title function_ invoke__">get_wallet_color</span>());</span><br><span class="line">    xiaoming.<span class="title function_ invoke__">change_wallet</span>(&amp;new_wallet);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;小明的钱包颜色是: &#123;&#125;&quot;</span>, xiaoming.<span class="title function_ invoke__">get_wallet_color</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Wallet</span> &#123;</span><br><span class="line">    color: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span>&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    wallet: &amp;<span class="symbol">&#x27;a</span> Wallet,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;<span class="symbol">&#x27;a</span>&gt; Person&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">get_wallet_color</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span> &#123;</span><br><span class="line">        &amp;<span class="keyword">self</span>.wallet.color</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">change_wallet</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, new_wallet: &amp;<span class="symbol">&#x27;a</span> Wallet) &#123;</span><br><span class="line">        <span class="keyword">self</span>.wallet = new_wallet</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行上述代码，得到的控制台输出为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">小明的钱包颜色是: 红色</span><br><span class="line">小明的钱包颜色是: 蓝色</span><br></pre></td></tr></table></figure><p>当然生命周期的标识也不能乱标，因为实实在在有可能误导编译器给你带来麻烦，就像一段代码的执行逻辑通过错误的注释可以引导读你代码的人走向错误的理解一样，我将循序渐进的带你走向错误，并向你展示<strong>生命周期的约束语法</strong>，需要注意的是它是用于表示一种关系。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">wallet</span> = Wallet &#123;</span><br><span class="line">        color: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;红色&quot;</span>),</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> <span class="variable">new_wallet</span> = Wallet &#123;</span><br><span class="line">        color: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;蓝色&quot;</span>),</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">xiaoming</span> = Person &#123; wallet: &amp;wallet &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;小明的钱包颜色是: &#123;&#125;&quot;</span>, xiaoming.<span class="title function_ invoke__">get_wallet_color</span>());</span><br><span class="line">    xiaoming.<span class="title function_ invoke__">change_wallet</span>(&amp;new_wallet);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;小明的钱包颜色是: &#123;&#125;&quot;</span>, xiaoming.<span class="title function_ invoke__">get_wallet_color</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Wallet</span> &#123;</span><br><span class="line">    color: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span>&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    wallet: &amp;<span class="symbol">&#x27;a</span> Wallet,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;<span class="symbol">&#x27;b</span>: <span class="symbol">&#x27;a</span>, <span class="symbol">&#x27;a</span>&gt; Person&lt;<span class="symbol">&#x27;a</span>&gt; &#123; <span class="comment">// changed here</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">get_wallet_color</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span> &#123;</span><br><span class="line">        &amp;<span class="keyword">self</span>.wallet.color</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">change_wallet</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, new_wallet: &amp;<span class="symbol">&#x27;b</span> Wallet) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;a</span> Wallet &#123; <span class="comment">// changed here</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">old_wallet</span> = <span class="keyword">self</span>.wallet;</span><br><span class="line">        <span class="keyword">self</span>.wallet = new_wallet;</span><br><span class="line">        old_wallet</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意此处相较于之前增加了<code>&#39;b: &#39;a</code>的标注，以及新增了一个返回值，这是什么意思呢？</p><ul><li><code>&#39;b: &#39;a </code>的意图是告诉编译器，我<code>&#39;b</code>标识的引用必然要比<code>&#39;a</code>活得一样久甚至更久，如果不是编译器就拒绝执行代码</li><li>此时返回值的生命周期标识是<code>&#39;a</code>也就是当前实例的生命周期</li></ul><p><code>&#39;b</code>比<code>&#39;a</code>活得久是必须的因为<code>&#39;a</code>表示的是当前结构体的实例，而<code>&#39;b</code>则表示的是我当前实例的引用，如果引用活的比实例要短，那么出现悬垂引用的情况是必然的，当然如果不习惯这种生命周期约束的语法，也是可以这样去声明的</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;<span class="symbol">&#x27;a</span>&gt; Person&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">change_wallet</span>&lt;<span class="symbol">&#x27;b</span>&gt;(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, new_wallet: &amp;<span class="symbol">&#x27;b</span> Wallet) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;a</span> Wal<span class="keyword">let</span></span><br><span class="line">    <span class="variable">where</span></span><br><span class="line">        <span class="symbol">&#x27;b</span>: <span class="symbol">&#x27;a</span>,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">old_wallet</span> = <span class="keyword">self</span>.wallet;</span><br><span class="line">        <span class="keyword">self</span>.wallet = new_wallet;</span><br><span class="line">        old_wallet</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果对生命周期约束，胡乱约束行不行呢？</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;<span class="symbol">&#x27;a</span>: <span class="symbol">&#x27;b</span>, <span class="symbol">&#x27;b</span>&gt; Person&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line"><span class="comment">// 一样的内容就不copy了</span></span><br><span class="line">  <span class="keyword">fn</span> <span class="title function_">change_wallet</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, new_wallet: &amp;<span class="symbol">&#x27;b</span> Wallet) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;a</span> Wallet &#123;</span><br><span class="line">  <span class="keyword">self</span>.wallet = new_wallet; <span class="comment">// --error 编译器马上就会告诉你，赋值要求b必须比a长</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设真的能够编译通过， 此处<code>&#39;a</code>表示的是当前实例的生命周期，而<code>&#39;b</code>表示的是要更换的钱包是实例中的引用，如果实例的生命周期要比引用更长，那么就可能会造成悬垂引用，我们这样写正在尝试制造一个悬垂引用，希望读者能在此处思考一下会发生什么？这个问题可以让读者检验自己是否已经掌握了生命周期的精髓，在现实中如果读者在使用生命周期标识的时候死活编译不过，你可以思考一下：你是否正在创建一个悬垂引用，或者生命周期标识的逻辑有误！因为它就是用来防止这个事的，当然你有的时候可能会陷入绝境，这个时候你可以与我探讨一下，可以利用一些机制进行解决。</p><p>那么我现在再次修改这个例子，只做一个很小的变动</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">change_wallet</span>(&amp;<span class="symbol">&#x27;a</span> <span class="keyword">mut</span> <span class="keyword">self</span>, new_wallet: &amp;<span class="symbol">&#x27;b</span> Wallet) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;a</span> Wallet &#123;</span><br><span class="line">      <span class="keyword">let</span> <span class="variable">old_wallet</span> = <span class="keyword">self</span>.wallet;</span><br><span class="line">      <span class="keyword">self</span>.wallet = new_wallet;</span><br><span class="line">      old_wallet</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不仔细看，你正儿八经都无法看出来修改何处，没错就是<code>&amp;&#39;a mut self</code> 我将<code>mut self</code> 标识成了与这个实例活的一样长，此时原本能执行的代码，就开始报错了</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">wallet</span> = Wallet &#123;</span><br><span class="line">        color: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;红色&quot;</span>),</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> <span class="variable">new_wallet</span> = Wallet &#123;</span><br><span class="line">        color: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;蓝色&quot;</span>),</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">xiaoming</span> = Person &#123; wallet: &amp;wallet &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;小明的钱包颜色是: &#123;&#125;&quot;</span>, xiaoming.<span class="title function_ invoke__">get_wallet_color</span>());</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">old_wallet</span> = xiaoming.<span class="title function_ invoke__">change_wallet</span>(&amp;new_wallet);</span><br><span class="line">  <span class="comment">// error: immutable borrow occurs here</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;旧钱包的颜色是：&#123;&#125;，小明的新钱包颜色是: &#123;&#125;&quot;</span>, old_wallet.color, xiaoming.<span class="title function_ invoke__">get_wallet_color</span>()); </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这个问题的出现就在于我们给编译器提示，这个可变引用会活的和实例一样长，所以导致我们没法再去使用一个不可变引用，根据借用规则：只能存在一个可变引用，且不能和不可变引用同时存在！  如果你不理解这个东西，有的时候你将会与编译器斗得头破血流的去换写法甚至直接放弃，所以不要慌，理解了之后自然可以从容面对。</p><p>对了，有一个特殊的生命周期标识符 <code>&#39;static</code>以及<code>T: &#39;static</code>没有说明，前者指的是引用必须要获得与程序一样久，后者指的是T必须活的与程序一样久，绝大多数情况下你并不需要它们，如果你真的需要多思考下设计是否存在问题，当然有的时候你为了编译通过也不是不行！毕竟在Rust的标准库中也有少量使用。</p><p>好了，本文结束，这篇文章几乎对Rust中生命周期的这些概念由浅入深的很清晰的进行了讲解，相信阅读过本文的读者对于这个概念都能够很好的掌握，如果你还不能掌握，我相信我这篇文章也为你打好了生命周期的基础可以帮助你去学习其它的资料。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Rust对于内存回收的机制，采取了一种与众不同的方式，当然这也不是新的概念，即&lt;strong&gt;RAII（Resource Acquisition Is Initialization）&lt;/strong&gt;的机制，这种机制起源于C++，但是在其它语言中都以不同的方式出现过，Rus</summary>
      
    
    
    
    
    <category term="rust" scheme="https://kongmingzi.com/tags/rust/"/>
    
  </entry>
  
  <entry>
    <title>HelloWorld</title>
    <link href="https://kongmingzi.com/2023/05/07/HelloWorld/"/>
    <id>https://kongmingzi.com/2023/05/07/HelloWorld/</id>
    <published>2023-05-07T13:34:33.000Z</published>
    <updated>2023-09-30T12:08:11.028Z</updated>
    
    <content type="html"><![CDATA[<p>距离上一次写博客，已经有很长一段时间了，嗯。。。我决定了今年重新开始写博客，以前的博文全部清空了，清空自己持有空杯心态。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;距离上一次写博客，已经有很长一段时间了，嗯。。。我决定了今年重新开始写博客，以前的博文全部清空了，清空自己持有空杯心态。&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
</feed>
